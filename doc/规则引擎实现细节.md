# 规则引擎实现细节

## 概述

规则引擎是文档格式检查的核心模块，负责加载规则、解析文档数据、执行规则匹配、收集检查结果。

---

## 规则模型

### 规则数据结构

参考 `rules_schema.json`，规则包含以下字段：

```python
{
    "id": "PAGE_MARGIN_25",  # 规则ID（必需）
    "name": "页面边距 2.5cm",  # 规则名称（必需）
    "category": "page",  # 规则分类（必需）
    "match": "document",  # 匹配目标（可选）
    "condition": {  # 匹配条件（必需）
        "top_mm": 25,
        "bottom_mm": 25,
        "left_mm": 25,
        "right_mm": 25
    },
    "error_message": "页面边距不符合 2.5cm 要求",  # 错误消息
    "suggestion": "请将页面边距设置为上/下/左/右 2.5cm",  # 修复建议
    "checker": "deterministic",  # 检查器类型（可选，默认deterministic）
    "metadata": {}  # 元数据（可选）
}
```

### 规则分类 (category)

| 分类 | 说明 | 匹配目标 |
|------|------|---------|
| `page` | 页面设置 | document |
| `font` | 字体样式 | run, paragraph |
| `paragraph` | 段落格式 | paragraph |
| `heading` | 标题格式 | section, style |
| `figure` | 图表格式 | figure, table |
| `reference` | 参考文献 | reference |
| `other` | 其他 | document, section, paragraph |

### 匹配目标 (match)

| 匹配目标 | 说明 | 数据来源 |
|---------|------|---------|
| `document` | 文档级别 | 文档整体设置（页面设置等） |
| `section` | 章节级别 | 标题结构 |
| `paragraph` | 段落级别 | paragraphs数组 |
| `run` | 文本运行级别 | runs数组 |
| `style` | 样式级别 | 段落/运行样式 |
| `table` | 表格级别 | tables数组 |
| `figure` | 图片级别 | figures数组 |
| `reference` | 参考文献 | 参考文献列表 |

---

## 规则执行流程

### 整体流程

```
1. 加载规则（从数据库或JSON文件）
   ↓
2. 解析文档（使用DocxParser）
   ↓
3. 遍历规则列表
   ↓
4. 对于每条规则：
   a. 根据match字段确定检查目标
   b. 提取对应的文档数据
   c. 执行condition匹配
   d. 如果不匹配，记录问题
   ↓
5. 收集所有问题，返回结果
```

### 详细流程

```python
def execute_check(document_path: str, rules: list) -> dict:
    """执行文档检查"""
    # 1. 解析文档
    parser = DocxParser(document_path)
    doc_data = parser.parse()
    
    # 2. 初始化结果
    issues = []
    
    # 3. 遍历规则
    for rule in rules:
        # 根据match字段获取检查目标数据
        targets = get_check_targets(doc_data, rule['match'])
        
        # 对每个目标执行检查
        for target in targets:
            if not match_condition(target, rule['condition'], rule['category']):
                # 条件不匹配，记录问题
                issue = create_issue(rule, target)
                issues.append(issue)
    
    # 4. 返回结果
    return {
        "total_issues": len(issues),
        "issues": issues
    }
```

---

## 条件匹配算法

### 匹配操作类型

根据 `category` 和 `condition` 字段的结构，支持以下匹配操作：

#### 1. 精确匹配 (Exact Match)
```python
# condition: {"font_name": "宋体"}
# 文档数据: {"font_name": "宋体"} → 匹配
# 文档数据: {"font_name": "黑体"} → 不匹配
```

#### 2. 数值比较 (Numeric Comparison)
```python
# condition: {"font_size_pt": 12}
# 文档数据: {"font_size_pt": 12} → 匹配
# 文档数据: {"font_size_pt": 14} → 不匹配

# 支持范围匹配（如果condition指定范围）
# condition: {"font_size_pt": {"min": 10, "max": 14}}
```

#### 3. 范围匹配 (Range Match)
```python
# condition: {"top_mm": 25, "tolerance_mm": 1}
# 文档数据: {"top_mm": 25.5} → 匹配（在容差范围内）
# 文档数据: {"top_mm": 27} → 不匹配
```

#### 4. 数组匹配 (Array Match)
```python
# condition: {"required": ["title", "abstract", "keywords"]}
# 检查文档是否包含所有必需的元素
```

#### 5. 正则匹配 (Regex Match，可选)
```python
# condition: {"pattern": "^图\\d+-\\d+.*"}
# 用于匹配图表编号格式
```

### 匹配函数实现

```python
def match_condition(target_data: dict, condition: dict, category: str) -> bool:
    """匹配条件
    
    Args:
        target_data: 文档数据（从文档中提取的对应部分）
        condition: 规则条件
        category: 规则分类
    
    Returns:
        True表示匹配（符合规则），False表示不匹配（有问题）
    """
    # 根据category选择匹配策略
    if category == "page":
        return match_page_condition(target_data, condition)
    elif category == "font":
        return match_font_condition(target_data, condition)
    elif category == "paragraph":
        return match_paragraph_condition(target_data, condition)
    # ... 其他分类
    else:
        return match_generic_condition(target_data, condition)


def match_page_condition(page_data: dict, condition: dict) -> bool:
    """匹配页面条件"""
    # 检查页面设置
    margins = page_data.get("margins", {})
    
    # 检查边距（允许容差）
    tolerance = condition.get("tolerance_mm", 0.5)  # 默认容差0.5mm
    
    for key in ["top_mm", "bottom_mm", "left_mm", "right_mm"]:
        if key in condition:
            expected = condition[key]
            actual = margins.get(key.replace("_mm", "").replace("top", "top"), 0)
            if abs(actual - expected) > tolerance:
                return False  # 不匹配
    
    # 检查纸张大小
    if "paper_name" in condition:
        paper_size = page_data.get("paper_size", {})
        # 检查是否为A4（210mm x 297mm）
        if condition["paper_name"] == "A4":
            width = paper_size.get("width_mm", 0)
            height = paper_size.get("height_mm", 0)
            if not (abs(width - 210) < 1 and abs(height - 297) < 1):
                return False
    
    return True  # 所有条件匹配


def match_font_condition(run_data: dict, condition: dict) -> bool:
    """匹配字体条件"""
    font = run_data.get("font", {})
    
    # 检查中文字体
    if "chinese_font" in condition:
        # 需要判断文本是否为中文
        text = run_data.get("text", "")
        if contains_chinese(text):
            if font.get("name") != condition["chinese_font"]:
                return False
    
    # 检查英文字体
    if "english_font" in condition:
        text = run_data.get("text", "")
        if contains_english(text):
            if font.get("name") != condition["english_font"]:
                return False
    
    # 检查字号
    if "chinese_size_pt" in condition:
        if contains_chinese(run_data.get("text", "")):
            if abs(font.get("size_pt", 0) - condition["chinese_size_pt"]) > 0.1:
                return False
    
    if "english_size_pt" in condition:
        if contains_english(run_data.get("text", "")):
            if abs(font.get("size_pt", 0) - condition["english_size_pt"]) > 0.1:
                return False
    
    return True


def match_paragraph_condition(para_data: dict, condition: dict) -> bool:
    """匹配段落条件"""
    formatting = para_data.get("formatting", {})
    
    # 检查首行缩进
    if "first_line_indent_chars" in condition:
        actual_chars = formatting.get("first_line_indent_chars", 0)
        expected_chars = condition["first_line_indent_chars"]
        if abs(actual_chars - expected_chars) > 0.5:  # 允许0.5字符容差
            return False
    
    # 检查行距
    if "paragraph_line_spacing" in condition:
        actual_spacing = formatting.get("line_spacing", 0)
        expected_spacing = condition["paragraph_line_spacing"]
        if abs(actual_spacing - expected_spacing) > 0.1:
            return False
    
    return True


def match_generic_condition(target_data: dict, condition: dict) -> bool:
    """通用条件匹配"""
    for key, expected_value in condition.items():
        actual_value = target_data.get(key)
        if actual_value != expected_value:
            return False
    return True
```

---

## 数据提取和映射

### get_check_targets 函数

```python
def get_check_targets(doc_data: dict, match_type: str) -> list:
    """根据match类型获取检查目标数据"""
    if match_type == "document":
        return [doc_data]  # 整个文档数据
    elif match_type == "paragraph":
        return doc_data.get("paragraphs", [])
    elif match_type == "run":
        return doc_data.get("runs", [])
    elif match_type == "heading":
        return doc_data.get("headings", [])
    elif match_type == "table":
        return doc_data.get("tables", [])
    elif match_type == "figure":
        return doc_data.get("figures", [])
    elif match_type == "section":
        # 章节需要从标题结构提取
        return extract_sections(doc_data)
    else:
        return []
```

### 数据提取示例

#### 页面设置提取
```python
# match = "document"
target_data = {
    "page_settings": {
        "margins": {
            "top_mm": 25.4,
            "bottom_mm": 25.4,
            "left_mm": 25.4,
            "right_mm": 25.4
        },
        "paper_size": {
            "width_mm": 210,
            "height_mm": 297
        }
    }
}
```

#### 段落数据提取
```python
# match = "paragraph"
target_data = {
    "index": 3,
    "text": "这是段落文本",
    "formatting": {
        "first_line_indent_chars": 2,
        "line_spacing": 1.5
    }
}
```

#### 字体数据提取
```python
# match = "run"
target_data = {
    "paragraph_index": 3,
    "run_index": 0,
    "text": "中文文本English",
    "font": {
        "name": "宋体",
        "size_pt": 12
    }
}
```

---

## 问题生成

### create_issue 函数

```python
def create_issue(rule: dict, target_data: dict) -> dict:
    """创建问题记录"""
    location = build_location(target_data, rule.get("match", "document"))
    
    return {
        "rule_id": rule["id"],
        "rule_name": rule["name"],
        "category": rule["category"],
        "error_message": rule.get("error_message", "格式不符合规范"),
        "suggestion": rule.get("suggestion", ""),
        "location": location
    }


def build_location(target_data: dict, match_type: str) -> dict:
    """构建位置信息"""
    location = {"type": match_type}
    
    if match_type == "paragraph":
        location["index"] = target_data.get("index")
        location["description"] = f"第{target_data.get('index', 0) + 1}段"
    elif match_type == "run":
        location["paragraph_index"] = target_data.get("paragraph_index")
        location["description"] = f"第{target_data.get('paragraph_index', 0) + 1}段文本"
    elif match_type == "heading":
        location["level"] = target_data.get("level")
        location["text"] = target_data.get("text")
        location["description"] = f"标题: {target_data.get('text', '')}"
    elif match_type == "document":
        location["description"] = "文档整体设置"
    
    return location
```

---

## 规则加载

### 从数据库加载

```python
def load_rules_from_db(db_session) -> list:
    """从数据库加载规则"""
    rules = db_session.query(Rule).all()
    return [rule_to_dict(rule) for rule in rules]


def rule_to_dict(rule) -> dict:
    """将数据库模型转换为字典"""
    return {
        "id": rule.id,
        "name": rule.name,
        "category": rule.category,
        "match": rule.match,
        "condition": json.loads(rule.condition_json) if rule.condition_json else {},
        "error_message": rule.error_message,
        "suggestion": rule.suggestion,
        "checker": rule.checker or "deterministic"
    }
```

### 从JSON文件加载

```python
import json

def load_rules_from_file(file_path: str) -> list:
    """从JSON文件加载规则"""
    with open(file_path, 'r', encoding='utf-8') as f:
        rules = json.load(f)
    return rules
```

---

## 规则执行器类

### RuleEngine 类

```python
class RuleEngine:
    """规则引擎"""
    
    def __init__(self, rules: list):
        self.rules = rules
        self.parser = None
    
    def check_document(self, document_path: str) -> dict:
        """检查文档"""
        # 1. 解析文档
        parser = DocxParser(document_path)
        doc_data = parser.parse()
        
        # 2. 执行规则检查
        issues = []
        for rule in self.rules:
            rule_issues = self._check_rule(rule, doc_data)
            issues.extend(rule_issues)
        
        # 3. 返回结果
        return {
            "total_issues": len(issues),
            "issues": issues
        }
    
    def _check_rule(self, rule: dict, doc_data: dict) -> list:
        """检查单个规则"""
        issues = []
        match_type = rule.get("match", "document")
        targets = get_check_targets(doc_data, match_type)
        
        for target in targets:
            if not match_condition(target, rule["condition"], rule["category"]):
                issue = create_issue(rule, target)
                issues.append(issue)
        
        return issues
```

---

## 示例规则执行

### 规则示例1：页面边距

```python
rule = {
    "id": "PAGE_MARGIN_25",
    "name": "页面边距 2.5cm",
    "category": "page",
    "match": "document",
    "condition": {
        "top_mm": 25,
        "bottom_mm": 25,
        "left_mm": 25,
        "right_mm": 25,
        "tolerance_mm": 0.5
    },
    "error_message": "页面边距不符合 2.5cm 要求",
    "suggestion": "请将页面边距设置为上/下/左/右 2.5cm"
}

# 执行流程：
# 1. match="document" → 获取文档的page_settings
# 2. 检查margins是否符合condition
# 3. 如果不符合，生成问题
```

### 规则示例2：正文字体

```python
rule = {
    "id": "FONT_BODY_SONGTI",
    "name": "正文字体为宋体",
    "category": "font",
    "match": "run",
    "condition": {
        "chinese_font": "宋体",
        "chinese_size_pt": 12,
        "english_font": "Times New Roman",
        "english_size_pt": 10.5
    },
    "error_message": "正文字体或字号不符合规范",
    "suggestion": "中文正文请使用 宋体 12pt，英文使用 Times New Roman 10.5pt"
}

# 执行流程：
# 1. match="run" → 获取所有runs
# 2. 对每个run，检查字体和字号
# 3. 判断文本是中文还是英文
# 4. 如果不符合，生成问题
```

---

## 性能优化建议

1. **规则缓存**: 规则加载后可以缓存
2. **并行检查**: 不同规则可以并行执行（如果文档数据已完全解析）
3. **早期退出**: 如果某个规则匹配，可以跳过该规则的后续检查
4. **数据预处理**: 对文档数据进行预处理，提取常用数据

---

## 测试策略

1. **单元测试**: 测试各个匹配函数
2. **集成测试**: 测试完整规则执行流程
3. **规则测试**: 为每个规则准备测试文档（符合/不符合的文档）
4. **边界测试**: 测试边界情况（空文档、大文档、特殊格式）

