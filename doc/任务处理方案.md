# 任务处理方案

## 概述

文档检查采用**异步任务模式**，客户端提交检查任务后立即返回任务ID，然后通过轮询方式查询任务状态和结果。

---

## 为什么使用异步模式？

### 1. 处理时间差异
- **基础检查（deterministic规则）**: 通常5-10秒完成
- **AI检查（full检查）**: 可能需要30-60秒甚至更长
- 如果使用同步模式，HTTP请求会超时（通常30-60秒超时）

### 2. 用户体验
- 异步模式可以显示进度，用户体验更好
- 用户可以关闭页面，稍后查看结果
- 不会因为长时间等待导致浏览器超时

### 3. 系统稳定性
- 避免长时间占用HTTP连接
- 可以更好地处理并发请求
- 任务失败可以重试

---

## 任务流程

### 整体流程

```
1. 客户端提交检查任务
   POST /check
   ↓
2. 服务器立即返回任务ID
   {check_id: "check_123", status: "pending"}
   ↓
3. 服务器后台异步处理任务
   - 解析文档
   - 执行规则检查
   - 保存结果
   ↓
4. 客户端轮询查询结果
   GET /check/{check_id}
   - status: "processing" → 继续轮询
   - status: "completed" → 显示结果
   - status: "failed" → 显示错误
```

### 详细时序图

```
客户端                    服务器                    后台任务
  |                         |                         |
  |-- POST /check ---------->|                         |
  |                         |-- 创建任务记录 --------->|
  |                         |-- 返回任务ID -----------|
  |<-- {check_id, pending} --|                         |
  |                         |                         |
  |                         |-- 启动后台任务 --------->|
  |                         |                         |-- 解析文档
  |                         |                         |-- 执行检查
  |                         |                         |-- 保存结果
  |                         |                         |
  |-- GET /check/{id} ------>|                         |
  |<-- {status: processing} -|                         |
  |                         |                         |
  |-- GET /check/{id} ------>|                         |
  |<-- {status: processing} -|                         |
  |                         |                         |
  |-- GET /check/{id} ------>|                         |
  |<-- {status: completed} -|                         |
  |                         |                         |
```

---

## 任务状态

### 状态定义

| 状态 | 说明 | 客户端行为 |
|------|------|-----------|
| `pending` | 任务已创建，等待处理 | 开始轮询 |
| `processing` | 任务正在处理中 | 继续轮询，显示进度 |
| `completed` | 任务已完成 | 停止轮询，显示结果 |
| `failed` | 任务失败 | 停止轮询，显示错误 |

### 状态转换

```
pending → processing → completed
                    ↘ failed
```

---

## 实现方案

### 方案1：后台任务队列（推荐，后续优化）

使用任务队列（如Celery、RQ）处理检查任务：

```python
# 使用Celery示例
from celery import Celery

celery_app = Celery('doc_checker')

@celery_app.task
def process_check_task(check_id: str, file_path: str, check_type: str):
    """后台处理检查任务"""
    # 1. 更新状态为processing
    update_check_status(check_id, "processing")
    
    # 2. 解析文档
    parser = DocxParser(file_path)
    doc_data = parser.parse()
    
    # 3. 执行检查
    rule_engine = RuleEngine(load_rules())
    result = rule_engine.check_document(file_path)
    
    # 4. 保存结果
    save_check_result(check_id, result)
    
    # 5. 更新状态为completed
    update_check_status(check_id, "completed", result)
```

**优点**：
- 可以处理大量并发任务
- 支持任务重试
- 可以监控任务状态

**缺点**：
- 需要额外的消息队列服务（Redis/RabbitMQ）
- 实现复杂度较高

### 方案2：线程池（MVP阶段推荐）

使用Python的线程池处理任务：

```python
from concurrent.futures import ThreadPoolExecutor
import threading

executor = ThreadPoolExecutor(max_workers=5)

@app.post("/check")
async def submit_check(file_id: str, check_type: str, user: User):
    # 1. 创建任务记录
    check_id = generate_check_id()
    create_check_record(check_id, file_id, "pending")
    
    # 2. 提交后台任务
    executor.submit(process_check_task, check_id, file_path, check_type)
    
    # 3. 立即返回任务ID
    return {"check_id": check_id, "status": "pending"}
```

**优点**：
- 实现简单，不需要额外服务
- 适合MVP阶段

**缺点**：
- 服务器重启后任务会丢失
- 不适合大规模并发

### 方案3：FastAPI BackgroundTasks（最简单）

使用FastAPI的BackgroundTasks：

```python
from fastapi import BackgroundTasks

@app.post("/check")
async def submit_check(
    file_id: str, 
    check_type: str, 
    background_tasks: BackgroundTasks,
    user: User
):
    # 1. 创建任务记录
    check_id = generate_check_id()
    create_check_record(check_id, file_id, "pending")
    
    # 2. 添加后台任务
    background_tasks.add_task(process_check_task, check_id, file_path, check_type)
    
    # 3. 立即返回
    return {"check_id": check_id, "status": "pending"}
```

**优点**：
- 最简单，无需额外配置
- 适合MVP阶段

**缺点**：
- 服务器重启后任务会丢失
- 不适合长时间运行的任务

---

## 客户端轮询实现

### JavaScript示例

```javascript
async function pollCheckResult(checkId, token, onProgress) {
  const maxAttempts = 60; // 最多轮询60次（约2分钟）
  const pollInterval = 2000; // 每2秒查询一次
  let attempts = 0;
  
  while (attempts < maxAttempts) {
    try {
      const response = await fetch(`/api/v1/check/${checkId}`, {
        headers: {
          'Authorization': `Bearer ${token}`
        }
      });
      
      const result = await response.json();
      const { status, progress, message, result: checkResult } = result.data;
      
      // 调用进度回调
      if (onProgress) {
        onProgress({ status, progress, message });
      }
      
      if (status === 'completed') {
        return checkResult; // 检查完成
      } else if (status === 'failed') {
        throw new Error(result.data.error_message);
      }
      
      // 等待后继续轮询
      await new Promise(resolve => setTimeout(resolve, pollInterval));
      attempts++;
    } catch (error) {
      throw error;
    }
  }
  
  throw new Error('检查超时');
}

// 使用示例
const checkId = 'check_1234567890';

pollCheckResult(checkId, token, ({ status, progress, message }) => {
  console.log(`状态: ${status}, 进度: ${progress}%, 消息: ${message}`);
  // 更新UI显示进度
  updateProgressBar(progress);
  updateStatusMessage(message);
})
.then(result => {
  console.log('检查完成:', result);
  displayCheckResult(result);
})
.catch(error => {
  console.error('检查失败:', error);
  showErrorMessage(error.message);
});
```

### Vue 3示例

```vue
<template>
  <div>
    <div v-if="status === 'processing'">
      <el-progress :percentage="progress" :status="progressStatus" />
      <p>{{ progressMessage }}</p>
    </div>
    <div v-else-if="status === 'completed'">
      <CheckResult :result="checkResult" />
    </div>
    <div v-else-if="status === 'failed'">
      <el-alert :title="errorMessage" type="error" />
    </div>
  </div>
</template>

<script setup>
import { ref, onMounted, onUnmounted } from 'vue'

const checkId = ref('')
const status = ref('pending')
const progress = ref(0)
const progressMessage = ref('')
const checkResult = ref(null)
const errorMessage = ref('')
let pollTimer = null

async function pollCheckResult() {
  try {
    const response = await fetch(`/api/v1/check/${checkId.value}`, {
      headers: {
        'Authorization': `Bearer ${token}`
      }
    })
    
    const result = await response.json()
    const data = result.data
    
    status.value = data.status
    progress.value = data.progress || 0
    progressMessage.value = data.message || ''
    
    if (data.status === 'completed') {
      checkResult.value = data.result
      stopPolling()
    } else if (data.status === 'failed') {
      errorMessage.value = data.error_message
      stopPolling()
    }
  } catch (error) {
    errorMessage.value = error.message
    status.value = 'failed'
    stopPolling()
  }
}

function startPolling() {
  pollTimer = setInterval(pollCheckResult, 2000)
}

function stopPolling() {
  if (pollTimer) {
    clearInterval(pollTimer)
    pollTimer = null
  }
}

onMounted(() => {
  startPolling()
})

onUnmounted(() => {
  stopPolling()
})
</script>
```

---

## 进度反馈（可选，后续优化）

### 进度信息

```python
def process_check_task_with_progress(check_id: str, file_path: str):
    """带进度反馈的任务处理"""
    # 更新进度：10% - 开始解析文档
    update_check_progress(check_id, 10, "正在解析文档...")
    doc_data = parser.parse(file_path)
    
    # 更新进度：30% - 开始执行规则检查
    update_check_progress(check_id, 30, "正在执行规则检查...")
    issues = []
    
    rules = load_rules()
    total_rules = len(rules)
    for idx, rule in enumerate(rules):
        rule_issues = check_rule(rule, doc_data)
        issues.extend(rule_issues)
        
        # 更新进度：30% + (idx/total_rules) * 60%
        progress = 30 + int((idx + 1) / total_rules * 60)
        update_check_progress(check_id, progress, f"正在检查规则: {rule['name']}")
    
    # 更新进度：100% - 完成
    update_check_progress(check_id, 100, "检查完成")
    save_check_result(check_id, {"total_issues": len(issues), "issues": issues})
```

### 数据库字段

```sql
ALTER TABLE checks ADD COLUMN progress INT DEFAULT 0 COMMENT '进度百分比';
ALTER TABLE checks ADD COLUMN progress_message VARCHAR(255) COMMENT '进度消息';
```

---

## 任务超时处理

### 超时设置

```python
# 配置
CHECK_TIMEOUT_SECONDS = 300  # 5分钟超时

def process_check_task(check_id: str, file_path: str):
    start_time = time.time()
    
    try:
        # 执行检查...
        result = execute_check(file_path)
        
        # 检查是否超时
        elapsed = time.time() - start_time
        if elapsed > CHECK_TIMEOUT_SECONDS:
            raise TimeoutError("检查超时")
        
        save_check_result(check_id, result)
    except Exception as e:
        mark_check_failed(check_id, str(e))
```

### 定时清理任务

```python
# 定时任务：清理超时的任务
def cleanup_timeout_tasks():
    """清理超过5分钟未完成的任务"""
    timeout_checks = db.query(Check).filter(
        Check.status.in_(["pending", "processing"]),
        Check.created_at < datetime.now() - timedelta(minutes=5)
    ).all()
    
    for check in timeout_checks:
        mark_check_failed(check.id, "任务超时")
```

---

## MVP阶段建议

### 推荐方案

**使用FastAPI BackgroundTasks**：
- 实现简单，无需额外服务
- 适合MVP阶段的低并发场景
- 后续可以轻松迁移到Celery

### 实现步骤

1. 提交任务接口：立即返回任务ID
2. 后台任务处理：使用BackgroundTasks
3. 查询结果接口：返回任务状态和结果
4. 客户端轮询：每2-3秒查询一次

### 后续优化方向

1. 引入任务队列（Celery + Redis）
2. 添加进度反馈
3. 支持任务取消
4. 任务重试机制
5. WebSocket推送（替代轮询）

---

## 总结

- ✅ **异步模式**：提交任务后立即返回任务ID
- ✅ **轮询查询**：客户端定期查询任务状态
- ✅ **状态管理**：pending → processing → completed/failed
- ✅ **MVP实现**：使用FastAPI BackgroundTasks
- ✅ **后续优化**：迁移到任务队列，添加进度反馈

